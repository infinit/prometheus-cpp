import drake
import drake.cmake
import drake.cxx
import os

# The paths to the libprometheus-cpp headers.
prometheus_include_path = []
# The path to the libprometheus-cpp library.
prometheus_lib = None
sources = None
cxx_config = None

def configure(
    cxx_toolkit,
    in_cxx_config,
    protoc,
    protobuf_config,
    protobuf_lib,
    cmake_vars = {}
):
  global prometheus_include_path, prometheus_lib, sources
  prometheus_include_path = [
    # libprometheus-cpp's header.
    drake.path_root() / drake.path_source('include'),
    # prometheus_client_model, a submodule, that contains the protobuf
    # support: metrics.pb.h.
    drake.path_root() / drake.path_build('lib/cpp'),
  ]
  prometheus_lib = drake.cxx.DynLib('lib/prometheus-cpp', tk = cxx_toolkit)
  srcs = [protoc, protobuf_lib] + drake.nodes(
    'CMakeLists.txt',
    'include/prometheus/collectable.h',
    'include/prometheus/counter.h',
    'include/prometheus/counter_builder.h',
    'include/prometheus/exposer.h',
    'include/prometheus/family.h',
    'include/prometheus/gauge.h',
    'include/prometheus/gauge_builder.h',
    'include/prometheus/histogram.h',
    'include/prometheus/histogram_builder.h',
    'include/prometheus/metric.h',
    'include/prometheus/registry.h',
    'lib/counter.cc',
    'lib/counter_builder.cc',
    'lib/exposer.cc',
    'lib/gauge.cc',
    'lib/gauge_builder.cc',
    'lib/handler.cc',
    'lib/handler.h',
    'lib/histogram.cc',
    'lib/histogram_builder.cc',
    'lib/json_serializer.cc',
    'lib/json_serializer.h',
    'lib/protobuf_delimited_serializer.cc',
    'lib/protobuf_delimited_serializer.h',
    'lib/registry.cc',
    'lib/serializer.h',
    'lib/text_serializer.cc',
    'lib/text_serializer.h',
    )

  dsts = [prometheus_lib] + drake.nodes(
    'lib/cpp/metrics.pb.h'
    )

  # Makefile target to run.
  targets = [
    'prometheus-cpp',
  ]

  class PrometheusCMakeBuilder(drake.cmake.CMakeBuilder):

    def execute(self):
      if not super().execute():
        return False
      self.cmd(
        'Fix rpath for {}'.format(prometheus_lib),
        cxx_toolkit.rpath_set_command(prometheus_lib, '.'))
      drake.cxx.set_lib_id(prometheus_lib.path())
      return True

  cmake_vars.update({
    'BUILD_SHARED_LIBS': 'ON',
    'PROTOBUF_INCLUDE_DIR': protobuf_config.protobuf_include_dir,
    'PROTOBUF_LIBRARY': protobuf_lib.path(absolute = True),
    'PROTOBUF_PROTOC_EXECUTABLE': protoc.path(absolute = True),
    # CivetWeb, a small HTTP in C and C++, is used an a "object"
    # library (aka "convenience library" in Libtool parlance) in
    # libprometheus-cpp.  But compiling the latter as a shared library
    # does not make the former PIC.  So force -fPIC.
    # https://cmake.org/pipermail/cmake/2012-June/050941.html
    'CMAKE_C_FLAGS': '-fPIC' ,
    'CMAKE_CXX_FLAGS': (('-stdlib=libc++' if cxx_toolkit.os == drake.os.macos else '')
                        + ' -fPIC'),
    })
  if drake.path_source().absolute():
    cmake_source = drake.path_source() / drake.Drake.current.prefix
  else:
    cmake_source = '../../../../prometheus/prometheus-cpp'

  cmake = PrometheusCMakeBuilder(cxx_toolkit, srcs, dsts, cmake_vars,
                                 targets = targets,
                                 path_to_cmake_source = cmake_source)
  global cxx_config
  cxx_config = drake.cxx.Config(in_cxx_config)
  cxx_config += protobuf_config



# Local Variables:
# mode: python
# End:
